#include <fstream>
#include <iomanip>
#include <stdlib.h>
#include <unordered_set>
#include <vector>
#include <string>
#include <iostream>

#include <swift/Basic/LLVMInitialize.h>
#include <swift/FrontendTool/FrontendTool.h>

// TODO: move elsewhere with patchFrontendOptions
#include <llvm/ADT/SmallString.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Path.h>
#include <swift/Basic/OutputFileMap.h>

#include "SwiftExtractor.h"

using namespace std::string_literals;

// This is part of the swiftFrontendTool interface, we hook into the
// compilation pipeline and extract files after the Swift frontend performed
// semantic analysys
class Observer : public swift::FrontendObserver {
 public:
  explicit Observer(const codeql::SwiftExtractorConfiguration& config) : config{config} {}

  void performedSemanticAnalysis(swift::CompilerInstance& compiler) override {
    codeql::extractSwiftFiles(config, compiler);
  }

 private:
  const codeql::SwiftExtractorConfiguration& config;
};

static std::string getenv_or(const char* envvar, const std::string& def) {
  if (const char* var = getenv(envvar)) {
    return var;
  }
  return def;
}

// TODO: move elsewhere
static void patchFrontendOptions(std::vector<std::string>& frontendOptions) {
  // TODO: handle filelists?
  // TODO: handle -Xcc arguments (e.g. -Xcc -Isomething)?
  std::unordered_set<std::string> pathRewriteOptions({
      "-emit-dependencies-path",
      "-emit-module-path",
      "-emit-module-doc-path",
      "-emit-module-source-info-path",
      "-emit-objc-header-path",
      "-emit-reference-dependencies-path",
      "-index-store-path",
      "-module-cache-path",
      "-o",
      "-pch-output-dir",
      "-serialize-diagnostics-path",
  });

  std::unordered_set<std::string> searchPathRewriteOptions({"-I", "-F"});

  // Defaulting to then root assuming that all the paths are absolute
  // TODO: be more flexible and check if the path is actually an absolute one
  auto pathRewritePrefix = getenv_or("CODEQL_EXTRACTOR_SWIFT_SCRATCH_DIR", "./");
  pathRewritePrefix += "/swift-extraction-artifacts";

  std::vector<size_t> searchPathIndexes;
  size_t supplementaryOutputsMapIndex = 0;
  std::vector<std::string> maybeInput;

  std::vector<std::string> newLocations;
  for (size_t i = 0; i < frontendOptions.size(); i++) {
    if (pathRewriteOptions.count(frontendOptions[i])) {
      auto oldPath = frontendOptions[i + 1];
      auto newPath = pathRewritePrefix + '/' + oldPath;
      frontendOptions[++i] = newPath;
      newLocations.push_back(newPath);
    } else if (frontendOptions[i] == "-supplementary-output-file-map") {
      supplementaryOutputsMapIndex = i + 1;
    } else if (searchPathRewriteOptions.count(frontendOptions[i])) {
      // Collect search path options indexes for further new search path insertion
      searchPathIndexes.push_back(i);
    } else if (frontendOptions[i][0] != '-') {
      // Maybe it's an input file generated by a previous invocation
      // In which case attempt to rewrite the argument if the new path exists
      auto oldPath = frontendOptions[i];
      maybeInput.push_back(oldPath);
      auto newPath = pathRewritePrefix + '/' + oldPath;
      if (llvm::sys::fs::exists(newPath)) {
        frontendOptions[i] = newPath;
      }
    }
  }

  if (supplementaryOutputsMapIndex != 0) {
    auto oldPath = frontendOptions[supplementaryOutputsMapIndex];
    auto newPath = pathRewritePrefix + '/' + oldPath;
    frontendOptions[supplementaryOutputsMapIndex] = newPath;

    llvm::errs() << "DEBUGG: map" << newPath << "\n";

    // TODO: do not assume absolute path
    auto outputMapOrError = swift::OutputFileMap::loadFromPath(oldPath, "");
    if (outputMapOrError) {
      auto oldOutputMap = outputMapOrError.get();
      swift::OutputFileMap newOutputMap;
      std::vector<llvm::StringRef> keys;
      llvm::errs() << "DEBUGG: got map"
                   << "\n";
      for (auto& key : maybeInput) {
        llvm::errs() << "DEBUGG: map key " << key << "\n";
        auto oldMap = oldOutputMap.getOutputMapForInput(key);
        if (oldMap) {
          keys.push_back(key);
          auto& newMap = newOutputMap.getOrCreateOutputMapForInput(key);
          newMap.copyFrom(*oldMap);
          for (auto& entry : newMap) {
            entry.getSecond() = pathRewritePrefix + '/' + entry.getSecond();
            llvm::errs() << "DEBUGG: rewritten entry " << entry.second << "\n";
          }
        }
      }
      std::error_code ec;
      llvm::SmallString<PATH_MAX> filepath(newPath);
      llvm::StringRef parent = llvm::sys::path::parent_path(filepath);
      if (std::error_code ec = llvm::sys::fs::create_directories(parent)) {
        std::cerr << "Cannot create relocated output map dir: " << ec.message() << "\n";
        return;
      }

      llvm::raw_fd_ostream fd(newPath, ec, llvm::sys::fs::OF_None);
      newOutputMap.write(fd, keys);
    }
  }

  std::reverse(std::begin(searchPathIndexes), std::end(searchPathIndexes));
  for (auto index : searchPathIndexes) {
    // Inserting new search path right before the existing ones
    auto option = frontendOptions[index];
    auto oldSearchPath = frontendOptions[index + 1];
    auto newSearchPath = pathRewritePrefix + '/' + oldSearchPath;
    if (llvm::sys::fs::exists(newSearchPath)) {
      auto it = frontendOptions.begin();
      std::advance(it, index);
      it = frontendOptions.insert(it, newSearchPath);
      frontendOptions.insert(it, option);
    }
  }

  // Re-create the directories in case Swift frontend expects them to be present
  for (auto& location : newLocations) {
    llvm::SmallString<PATH_MAX> filepath(location);
    llvm::StringRef parent = llvm::sys::path::parent_path(filepath);
    if (std::error_code ec = llvm::sys::fs::create_directories(parent)) {
      std::cerr << "Cannot create patched directory: " << ec.message() << "\n";
      return;
    }
  }
}

static void attemptToCopyMergedModule(const std::vector<std::string>& options) {
  // DerivedData/MovieSwift/Build/Intermediates.noindex/SwiftUIFlux.build/Debug-iphoneos/SwiftUIFlux.build/Objects-normal/arm64/SwiftUIFlux.swiftmodule
  // DerivedData/MovieSwift/Build/Products/Debug-iphoneos/SwiftUIFlux.swiftmodule/arm64.swiftmodule
  if (options[0] == "-merge-modules") {
    llvm::StringRef modulePath;
    for (size_t i = 0; i < options.size(); i++) {
      if (options[i] == "-o") {
        modulePath = options[i + 1];
      }
    }
    if (modulePath.empty()) {
      return;
    }

    llvm::SmallVector<llvm::StringRef> chunks;
    modulePath.split(chunks, '/');
    size_t intermediatesDirIndex = 0;
    for (size_t i = 0; i < chunks.size(); i++) {
      // Intermediates.noindex
      if (chunks[i] == "Intermediates.noindex") {
        intermediatesDirIndex = i;
        break;
      }
    }
    if (intermediatesDirIndex == 0) {
      return;
    }
    // e.g. Denug-iphones, Release-iphonesimulator, etc.
    auto destinationDir = chunks[intermediatesDirIndex + 2].str();
    auto arch = chunks[intermediatesDirIndex + 5].str();
    auto moduleName = chunks.back().str();
    std::string relocatedModulePath;
    for (size_t i = 0; i < intermediatesDirIndex; i++) {
      relocatedModulePath += '/' + chunks[i].str();
    }
    relocatedModulePath += "/Products/";
    relocatedModulePath += destinationDir + '/';
    relocatedModulePath += moduleName + '/';
    relocatedModulePath += arch + ".swiftmodule";
    llvm::SmallString<PATH_MAX> filepath(relocatedModulePath);
    llvm::StringRef parent = llvm::sys::path::parent_path(filepath);
    if (std::error_code ec = llvm::sys::fs::create_directories(parent)) {
      std::cerr << "Cannot create relocated module path: " << ec.message() << "\n";
      return;
    }

    llvm::SmallString<PATH_MAX> srcFilePath(modulePath);
    llvm::SmallString<PATH_MAX> dstFilePath(relocatedModulePath);

    if (std::error_code ec = llvm::sys::fs::copy_file(srcFilePath, dstFilePath)) {
      std::cerr << "Cannot relocate archive '" << srcFilePath.str().str() << "' -> '"
                << dstFilePath.str().str() << "': " << ec.message() << "\n";
    }
  }
}

int main(int argc, char** argv) {
  if (argc == 1) {
    // TODO: print usage
    return 1;
  }
  // Required by Swift/LLVM
  PROGRAM_START(argc, argv);
  INITIALIZE_LLVM();

  codeql::SwiftExtractorConfiguration configuration{};
  configuration.trapDir = getenv_or("CODEQL_EXTRACTOR_SWIFT_TRAP_DIR", ".");
  configuration.sourceArchiveDir = getenv_or("CODEQL_EXTRACTOR_SWIFT_SOURCE_ARCHIVE_DIR", ".");

  configuration.frontendOptions.reserve(argc - 1);
  for (int i = 1; i < argc; i++) {
    configuration.frontendOptions.push_back(argv[i]);
  }
  configuration.patchedFrontendOptions = configuration.frontendOptions;
  patchFrontendOptions(configuration.patchedFrontendOptions);

  std::vector<const char*> args;
  std::cerr << "DEBUG swift-frontend-args:\n";
  for (auto& arg : configuration.patchedFrontendOptions) {
    args.push_back(arg.c_str());
    std::cerr << "  " << std::quoted(arg) << " \\\n";
  }
  std::cerr << "\n\n";

  Observer observer(configuration);
  int frontend_rc = swift::performFrontend(args, "swift-extractor", (void*)main, &observer);

  if (!frontend_rc) {
    attemptToCopyMergedModule(configuration.patchedFrontendOptions);
  }

  //-supplementary-output-file-map
  /// var/folders/10/hts02tt52j1b7x26bym0bp0c0000gn/T/TemporaryDirectory.860KhC/supplementaryOutputs-1

  for (size_t i = 0; i < configuration.frontendOptions.size(); i++) {
    if (configuration.patchedFrontendOptions[i] == "-supplementary-output-file-map") {
      auto mapFile = configuration.frontendOptions[i + 1];
      auto filepath = getenv_or("CODEQL_EXTRACTOR_SWIFT_SCRATCH_DIR", "/tmp") + "/maps/" + mapFile;
      llvm::StringRef parent = llvm::sys::path::parent_path(filepath);
      if (std::error_code ec = llvm::sys::fs::create_directories(parent)) {
        std::cerr << "Cannot create relocated map directory: " << ec.message() << "\n";
        return frontend_rc;
      }
      llvm::SmallString<PATH_MAX> srcFilePath(mapFile);
      llvm::SmallString<PATH_MAX> dstFilePath(filepath);

      if (std::error_code ec = llvm::sys::fs::copy_file(srcFilePath, dstFilePath)) {
        std::cerr << "Cannot relocate map file '" << srcFilePath.str().str() << "' -> '"
                  << dstFilePath.str().str() << "': " << ec.message() << "\n";
      }
    }
  }

  return frontend_rc;
}
